HTTPS : HTTP프로토콜 내용을 암호화
기존의 HTTP요청은 누군가 요청을 그대로 볼 수 있었음 => 하지만 HTTPS는 정확한 키가 없으면 볼 수 없다.
HTTPS는 인증서, CA, 비대칭 키 암호화 이용

인증서 : 데이터를 보내준 서버가 정말로 데이터를 보내준 서버인지 인증, 확인하는 용도. 인증서의 내용엔 서버의 도메인 관련 정보가 있어서 데이터 제공자의 인증을 용이하게 해준다.

서버는 요청을 받으면 서버는 인증서와 함께 응답을 전송, 클라이언트는 응답객체에 작성된 도메인과 인증서의 도메인을 비교해서 만약 다를경우에는 데이터 제공자가 서버인지 확실히 보장을 못한다.


CA : 인증서 발급해주는 공인 기관 . 각 브라우저는 각자 신뢰하는 CA의 정보를 가지고 있어서 인증서가 차이가 난다. CA는 자격이 무조건 유지되지 않는다.
비대칭 키 암호화 : 키A로 암호화 하되, 키 B로만 복호화가 가능하다. 키 하나는 공개해서 클라이언트가 사용할 수 있다??

공개키 방식은 모든 클라리언트에게 사용하기엔 연산이 많아 통신 초기에 비밀키를 만드는 용도로만 사용.

통신과정
1) handshake : 서로를 확인하고 서버는 클라이언트에게 공개키, 인증서 전달 / 서버 인증서 검증?
2) 비밀 키 생성 : 클라이언트는 전달받은 키를 이용해서 키 제작용 랜덤 스트링을 암호화해서 전달, 서버도 클라와 마찬가지로 암호화해서 전달. 클라이언트와 서버는 세션키를 생성하며 상호키 검증시 사용
3) 상호 키 검증 : 사용세션 키로 암호화된 메세지를 서로에게 전달해서 같으면 연결이 성립한다.


해싱이란?

 
암호화 :
암호화는 임의의 방식을 사용해서 다른 형태로 변환하여 해당 방식에 대한 정보를 소유한 사람을 제외하고 이해할 수 없도록 알고리즘을 이용해 정보를 관리하는 과정


솔팅 : salt를 비밀번호에 추가해서 암호화할 수 있도록 해줌. 유저마다 고유 값을 가져야 하고, DB에 salt를 저장해야 한다. 



쿠키 : 웹사이트에 들어갔을 때 서버가 일방적으로 클라이언트에 전달하는 작은 데이터 
-> 사용자 선호, 테마 등 장시간 보존해야 하는 정보 저장에 적합
-> 노출되면 안좋은 데이터나 개인정보, 인증에 관련된 정보는 포함하지 않는 것이 좋다.
-> 클라이언트에 저장되는 작은 텍스트데이터
-> 헤더에 담겨져 있음.



쿠키옵션 :

1. Domain : 작성된 도메인과 서버의 도메인이 일치하는 경우에만 쿠키 전송
2. Path : 작성된 세부경로가 일치하는 경우에만 쿠키전송
3. MaxAge or Expires : 쿠키 유효기간 설정
4. HttpOnly : 스크립트에서 쿠키 접근을 막아줌 => https랑 상관없음 
5. Secure : https프로토콜을 이용하는 경우에만 쿠키전송
6. SameSite : CORS에 대해서 쿠키를 전송할지 안할지 결정 => CSRF예방관련
무상태성

======> 일반적인 요청에는 쿠키가 같이 실려서 fetch가 되는데,(domain specific 하지 않은 쿠키)

CORS의 경우 fetch는 credentials:'include' 옵션을 넣어주거나 AJAX요청에선 withCredentials 를 true로 설정해야 한다.

로그아웃 : 서버가 세션에서 조재하는 정보를 지운다.
CSRF : 사이트 A가 사이트 B에서 사용자가 인증되는 동안 강제적으로 사이트 B에게 원하지 않는 포져리된 요청을 하는 경우를 말한다.

6. SameSite 옵션

1) Lax : GET 메서드 요청만 쿠키 전송 가능
2) Strict : 쿠키 전송 불가
3) None : 모든 메서드요청에 대해 쿠키 전송 가능 => Secure 사용해야..https도 사용해야 

XHR : ajax기술중 하나로 자바스크립트를 이용해서 http요청 보내는 것. SPA만들때 유용하며 cross-origin 요청을 보내기도 한다.
쿠키 : 브라우저에 담긴 작은 텍스트쪼가리. http의 무상태성을 보완.



세션

서버가 클라이언트에 유일하고 암호화된 ID부여 
중요데이터는 서버에서 관리
쿠키엔 데이터의 id를 암호화해서 쿠키에 저장



mksert - 사설인증기관



자동로그인이 되는 것은 쿠키가 세션아이디를 갖고있기 때문.




로그인이 성공하면 세션아이디을 생성. 및 브라우저에 응답 by setCookie.
이후 브라우저에서 내정보 조회할 경우 요청에 쿠키를 함께 보내서 확인.
쿠키와 POST 











